Java虚拟机
运行时数据区域：
1、程序计数器：记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
2、虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。
             每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
3、本地方法栈：本地方法不是用 Java 实现，与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
4、堆：所有对象实例都在这里分配内存。
       现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法
	   虚拟机把 Java 堆分成以下三块：新生代，老生代，永生代
	   
	   年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。
	   
	   当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。
	   新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高
	   新生代划分为三个空间：Eden，From survivor,To survivor
	   
	   一个对象的一辈子：我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。
	                     有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。
						 直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。
						 在年老代里，我生活了20年(每次GC加一岁)，然后被回收。
						 
5、方法区：用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
           对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
		   JDK1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收，JDK8 之后，取消了永久代，用 metaspace（元数据）区替代。		

6、运行时常量池：运行时常量池是方法区的一部分。
                 Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。

7、直接内存：在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，
             然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。	


垃圾收集：
判断一个对象是否可以回收：
1、引用计数：给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
             两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。
			 
2、可达性：通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是可用的，不可达的对象可被回收。
           GC Roots包含对象：虚拟机栈中引用的对象，
		                     方法区中类静态属性应用的对象，
							 方法区中的常量引用对象，
							 本地方法栈中引用的对象	

3、引用类型: a:强引用
               只要强引用存在，垃圾回收器永远不会回收被引用的对象。
               使用 new 一个新对象的方式来创建强引用。
         
             b:软引用
               用来描述一些还有用但是并非必需的对象。
               在系统将要发生内存溢出异常之前，会将这些对象列进回收范围之中进行第二次回收。	
 
             c:弱引用
			   只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会被回收。
			   
			 d:虚引用
               一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。	

4、方法区的回收：因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。
                 主要是对常量池的回收和对类的卸载。
                 类卸载条件：该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
				             加载该类的 ClassLoader 已经被回收。
							 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
							 
5、finalize():用来做关闭外部资源等工作,用来关闭无法正常回收的对象，防止内存泄露。


垃圾收集算法：
1、标记-清除：将需要回收的对象进行标记，然后清除。
              不足：标记和清除过程效率不高
                    会产生大量内存碎片，内存碎片过大会导致无法分配大内存对象	

2、标记-整理：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

3、复制：将内存划分为大小相等的两块，每次只使用其中一块，
         当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。
         HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。

4、分代收集：现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。
             新生代：复制算法
             老生代：标记-清除或者标记-整理算法	 
			 
垃圾收集器：

内存分配与回收策略：对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。	
1、优先在Eden区分配：大多数情况下，对象在新生代Eden区分配，当 Eden 区空间不够时，发起 Minor GC。 
                     关于Minor GC跟Full GC
					 Minor GC:发生在新生代上，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快
					 Full GC：发生在老年代，老年代对象和新生代的相反，其存活时间长，因此Full GC很少执行，因此执行速度会比Minor GC慢很多
					 
2、大对象直接进入老年代：
                     				 
          			 

			 